# 2022/10/24看项目视频 
Vuex中的数据，刷新页面就会重新初始化，导致数据丢失。因为 Vuex 里的数据是保存在运行内存中的，当页面刷新时，页面会重新加载 vue 实例，Vuex 里面的数据就会被清空。但是可以通过插件等一些方法持久化数据，还是有解决方法的，后续用到的时候再学 
# 2022/10/24看项目视频
**Vue3的setup()内部无法使用this**,官方解释是：this不会是该活跃实例的引用（即不指向vue实例），因为 setup() 是在解析其它组件选项之前被调用的，所以 setup() 内部的 this 的行为与其它选项中的 this 完全不同。这在和其它选项式 API 一起使用 setup() 时可能会导致混淆。因此所以setup函数中不能使用this，Vue直接将setup函数中的this改为了undefined。个人理解是：setup是在beforecreate和created之前，这时候vue对象还没被创建，所以没法使用this
# 2022/10/28看项目视频
watch要监视对象中的某个具体属性，必须watch(()=>demo.name,(newValue,oldValue)=>{}); 第一个参数必须是一个箭头函数，方法规定就是如此，更深层的要看Vue3源码了
# 2022/10/29看项目视频
Vue跨组件传值真得注意拷贝的问题，JS传对象、数组过去，不注意拷贝，很容易把原对象给改了，然后就传值乱套了，这就不是我们希望的了
# 2022/11/10
父组件给子组件传对象，是可以子组件更改的，比如父组件Game组件给子组件GameBox组件传一个timer,<GameBox v-model:timer="timer">，然后在子组件里定义下面代码，之后就可以用emit('update:timer', second.value)，用second.value的值来更新timer
``` 
	const emit = defineEmits(['update:timer'])
	let second = ref(props.timer) // 这样对second更改不会影响到timer的值
```
- vue3里规定v-model
	- 第一种不用v-model
	- `<Switch :value="value" @update:value="value=$event"/>`
	- 第二种用v-model
	- `<Switch v-model:value="value"/>`
- emit
```
	setup(props, context) {
      context.emit('update:value', newValue); //事件名 ，事件参数
    };

	method(){
	    this.$emit('update:value', newValue)
	}

	// 在setup语法糖中，可以直接使用emit
	emit('update:value', newValue)
```
- 知识点
	- props：由外部传值
	- emit 通过$event接受由内部传出的值
	- 两者结合实现了**子父组件**之间**通信**，该方法较为常用，于是尤雨溪设计了**v-model**将两者结合

# 2022/11/12写GBA游戏重置
可以通过@contextmenu.prevent.stop来禁用浏览器长按右键功能
# 2022/11/13写GBA游戏最快大脑关卡
audio播放音频，用ref获取元素，play()控制播放，pause()暂停，currentTime = 0.0 来控制从头播放

# 2022/11/29邵宇涵写项目
Vue中父子组件生命周期执行顺序：
`父beforeCreate-> 父create -> 子beforeCreate-> 子created -> 子mounted -> 父mounted`
所以子组件挂载完成时父组件还未挂载，所以组件数据回显的时候，在父组件mounted中获取api的数据，子组件的mounted是拿不到的。
解决方案为：在created中发起请求获取数据，依次在子组件的created或者mounted中会接收到这个数据。